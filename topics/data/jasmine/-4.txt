["this code seems to create the empty fixture div i'm looking for:```jasmine.getfixtures().set(sandbox())$('#sandbox').length === 1 //true```is this the way you'd recommend to create an empty fixture holder?", "someone's already registered jasmine-jquery with bower. and i don't use component.js so feel free to make a pr.", 'tyuwan steverob you should test it though `grunt jasmine` or `grunt jasmine-server`.it include some compile and build job.', 'fix spelling error of \'describe\' in jasmine patch. looks like a spelling error was preventing the jasmine patch from patching "describe".', 'i signed it!', 'clas look good. thanks!<!-- ok -->', "jasmine test shim masks third parameters (per-test timeout). the jasmine patch does not pass through third parameters to a test. so this won't work:``` jsit('takes a long time'. function(done) {  domylongtimeout().then(done);}. 10000);```", 'fix(jasmine): propagate all arguments of it/describe/etc...', 'travis failure looks legitimate. but also looks like it was caused by the previous commit.', "tsaikd. what's ugly about it? i wish the patch was available from upstream :(", 'juliemr in your example above it returns the length. but can you also use this to be able to use the .sendkeys() function to the element? have an element inside a tab. inside a directive and this is the only piece of code thats sent anything back from it.', 'evanburbidge yes. you should be able to do a number of things with the `element` in the example above. including `sendkeys()`.', 'any update on this issue; i\'m running into same problem after running last scenario\'s step in cucumber "error: this driver instance does not have a valid session id (did you call webdriver.quit()?) and may no longer be used." is this a bug in protractor? don\'t want to use noops as suggested earlier; a proper fix would be greatly appreciated.', 'still no update.  realistically. the frameworks need to provide the updates.', 'how to incorporate java script methods in protractor jasmine tests. do we need to use browser.executescript?', 'thanks nicktomlin', 'test failure: scene/composite3dtilecontent renders multiple instanced tilesets. scene/composite3dtilecontent renders multiple instanced tilesets is failing in the ci.```scene/composite3dtilecontent     renders multiple instanced tilesetserror: timeout - async callback was not invoked within timeout specified by jasmine.default_timeout_interval.', 'helper tests grouped by helper type . - the tests were grouped.- old javascript tests edited to use the new json format used in tests file- jasmine test edited to use the new json format used in tests file', 'awesome jairodemorais. ship it', 'can we do the same for the core helpers :)', 'vybs  yes we can :p', "isresolved() and isrejected() are both true. isresolved() and isrejected() are both true after rejecting a single defer/promise. this is either counter intuitive. or wrong.  please explain if i'm missing something here :)example jasmine test code: this test passes (i would expect it to fail)            var promise;```        function iscomplete() {            return promise.isrejected() || promise.isresolved();        }        function expectstate(obj) {            if (obj.hasownproperty('isrejected')) {                expect(promise.isrejected()).tobe(obj.isrejected);            }            if (obj.hasownproperty('isresolved')) {                expect(promise.isresolved()).tobe(obj.isresolved);            }            if (obj.hasownproperty('isfulfilled')) {                expect(promise.isfulfilled()).tobe(obj.isfulfilled);            }        }        function rejectandverifystate(fn. value. expectedstate) {            var defer = q.defer();            promise = fn(defer);            runs(function() {               defer.reject(value);            });            waitsfor(iscomplete);            runs(function() {               expectstate(expectedstate);            });        }         it('should set correct state when rejected'. function () {            rejectandverifystate(function(defer) {                return defer.promise;            }. 'failed'. { isrejected : true. isresolved : true. isfulfilled : false });        });```", 'a promise one primary axis of state:**resolved** vs. **deferred**if the promise is resolved. then it has another axis:**fulfilled** vs. **rejected**you are probably looking for `q.isfulfilled()` instead of `q.isresolved()`.', 'sorry. but this makes no sense. there are two distinct ways to complete a defer. either reject. or resolve. the isresolved and isrejected functions should report this state. how can both isrejected and isresolved be true? i understand that isfulfilled will report if the whole chain has been fullied.', '"a promise one primary axis of state:". that statement makes me think you agree with me. it should either be resolved. or rejected not both?', '> sorry. but this makes no sense. there are two distinct ways to complete a defer. either reject. or resolve.you can resolve a deferred with a promise. in this case. two things happen:- if the passed promise is already resolved. the underlying-promise adopts its state. becoming itself resolved.- if the passed promise is still pending. the underlying-promise stays in the pending state. waiting on the passed promise to resolve before adopting its state.notably. you can call `deferred.resolve(q.reject(new error()))` to achieve the same effect as `deferred.reject(new error())`. in this sense `deferred.reject` is just sugar; the only thing you can do with deferreds is resolve them. the effect on the underlying promise---whether it will be resolved. or stay pending---is determined by what you resolve the deferred _with_.> "a promise one primary axis of state:". that statement makes me think you agree with me. it should either be resolved. or rejected not both?you seem to have missed the subsequent line. where i explained that this axis is not resolved vs. rejected. but resolved vs. deferred. a promise can either be resolved or deferred. but not both. similarly. it can be either fulfilled or rejected. but not both. resolved can mean either rejected or fulfilled. however.', 'ok. so i should think of reject as resolvewithrejection :). thanks for taking the time to go through it', "> ok. so i should think of reject as resolvewithrejection :). thanks for taking the time to go through ityeah that's pretty much it :). thanks for sticking with me!", "still not sure i like the terminology. especially as your own description uses terms like pending. an ispending. or iscomplete with isrejected and isresolved being mutually exclusive would imo make more sense. but its a bit late to make that sort of change (lol). i guess i'm just coming at it from a .net tpl library perspective. thanks a lot  for the really quick responses. its rare. but means i can get on now and finish my work :)", 'well. the confusing thing is that "resolve" as a verb only applies to deferreds. whereas "resolved" as a state only applies to promises. :-/i agree that a `promise.ispending()` might clarify things. but that would just be the same as `!promise.isresolved()`. so it\'s not that helpful.kriskowal may have more to say. but glad i could get you moving in the right direction :)', "suedama1756 jquery's implementation is very basic and lacks a lot for a _promise_ solution. q would be very limited if it would try to be compliant with jquery's deferred.promise can be either _resolved_ or _unresolved_ and when it's resolved can be either _fulfilled_ or _rejected_. it's very logical and valid approach.", 'guys. i\'m not for one minute suggesting that you limit q\'s functionality (and i\'m not a fan of jquery full stop. for me. its a library from a different era). i think the functionality provided by q is fantastic. i really do. i just think the naming of promise states is a little unfortunate. they are not symmetrical with the methods resolve. reject (unless reject is named resolvewithrejection). api\'s should be discoverable. symmetrical and obvious. so far not one single developer in my team has answered the question correctly. "what do you think isresolved returns when you have rejected a deferred object". in reference to the promise/a specification there is no mention of the isrejected/isresolved states. in practice. most developers will use then() so this becomes a non-issue.the reality is that the states do make sense once you know about them. but you can\'t really argue with the fact that for most people. the isrejected and isresolved states do not return what is intuitively expected.great work regardless :)', '+1', "merged. let me know if it's not working.", 'i will set up a breaking case example. effectively i am using a top level sim link for library code and the template is injecting ../ before each of my cases. not a big deal for now. when i have more time i will put something together to show.', 'add one more map configuration to your `requireconfig`.``` jsmap: {    \'*\': {        "app": "../src/js"    }}```this mapping only needs to be added for jasmine task. development environment doesn\'t have to.', 'indeed. to those of us who do test-first development. the quality of errormessages in jasmine are essential to efficient development.  remember. wecan\'t write a line of production code until we get a failing test.  whenmany of our non-matcher messaes are all "attempted to assign to readonlyproperty." it puts a huge crimp in our work. particularly at the outsetwhen most messages are non-matcher errors.']