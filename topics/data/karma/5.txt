["webpack karma config. this adds a configuration for webpack as a reference to anyone using it over browserify since it requires some special configuration to work. there is a todo task here to make the tests run with both webpack and browserify configs in series. but that will take some work as the current test setup won't allow that easily. for now. having this example will help others to figure out how to get request working with webpack.", 'updated karma + config. tested and works.', 'looks good - thank you.', 'wow. that was quick!', 'clean commit and clean message makes for quick merges :)', 'fix(build): change src path for karma', "yeah. the router will definitely get hit in e2e tests.it may be true that we simply shouldn't try to test the router from the jasmine / karma tests. however. i like doing as much as possible from them because they're so much faster and reliable compared to protractor / selenium tests.", 'well benouat mentions the playground - whereas i am here interested in the tdd task (i know there is also a karma:tdd task. but i personally prefer the tddrt which i find more comfortable).so i will ineed move the renderer import inside the express function (will do this tonight) - thx.', "lyonlai i checked out your branch and couldn't get tests to pass using `grunt karma:chrome` and running them in debug mode.  i had initially tried an approach where the observermap was using a getter by reference as a key. however i couldn't get it it to pass tests.if you are able to get tests to pass i'm happy to include.", "jordangarcia while you are doing that i'll run karma manually to see if i can get the test running.", "lyonlai it's working for me. not sure if it's becuase i have a globally installed module that maybe you don't have.do you have karma install globally?are you running on osx?", 'cressie176 nothing works here. i just tested it with a simple `throw new error("xxx")`. what is interesting. that this is a node.js only issue. by using karma + browserify i got the stack.', '+1 currently. karma does not presently run correctly with the old-style configs and needs to be updated. other generators relying on this are presently failing.', 'not registered in yo list. running yo does not list the karma generator in the list of generators', 'yeah. we are planning to allow tests for karma and jest to co-exist and will detect and run them both.', 'load user karma config', "node.js test coverage. ## description:currently. ractive's coverage only covers the browser tests. since we use the same karma setup for all tests. it should be easy to add it to the node tests. but here's the catch...the coverage must be combined when reporting to coveralls to get the overall figure. unless coveralls merges tests from the same build. there might be a need to do merging and reporting manually instead of karma-coveralls.also gives way to just merging the coverage report to the test. instead of having a separate. redundant setup for it.not sure if this is a good idea. opinions are highly valued here.", "coverage to map to es source instead of bundle. ## description:would be nice if the coverage mapped to the raw source. that way. it's easy to find which portions of the code are left uncovered instead of hunting them down using the bundle. also. this would let coveralls map back to github for the source.i've read somewhere that karma can pre-process es modules so the reports generate based on the raw source. but i'm not sure how to tie it to the build.", 'yes to everything. except karma-babel-preprocessor ;)', "increase browser coverage. only a fraction of our test suite runs in browsers.  everything that should work in a browser should run in a browser.  here are some reasons:- mocha's i/o is not sufficiently abstracted.  too much node.js-specific stuff strewn throughout various places.  as a result. the specs suffer the same problem; they overwhelmingly expect a node.js environment.- initialization of interfaces (`tdd`. `bdd`. etc) and actually _running_ mocha differs wildly between node.js and the browser.  see `karma.conf.js` for examples of the broadway production necessary to simply test the `qunit` interface.- exposed globals and module exports are inconsistent.  for compatibility. `browser-entry.js` actually exports `global`. which is a profound wtf.  this probably has to do with the fact that mocha originally hand-rolled its own browserify implementation. _that being said_. i believe there are a small handful of tests that can be run with little or no modification which simply _aren't_ being run.to address this. start by telling karma to run everything. and then remove the tests that break.", "problem here is console.log's being logged twice when using the sauce reporter with another karma reporter.", 'make disconnected builds make as fail in sauce. this will make disconnected builds fail in sauce.currently if karma disconnects it still shows pass.', "in new wersion used next code in lib/sauce_launcher.jsthis.on('kill'. function(done) {    if (sessionisready) {      ....      driver.get('about:blank').catch().quit().nodeify(alldone);      sessionisready = false;    } else {      pendingcancellations++;      process.nexttick(alldone);    }  });};when i run karma with existing virtual tunnel and setted startconnect: false - all work excellentbut when i run with creating virtual tunel (default) tunnel not closingand event driver.get('about:blank').catch().quit().nodeify(alldone);do not fired", "dont close sauce-launcher. in new wersion used next code in lib/sauce_launcher.jsthis.on('kill'. function(done) {    if (sessionisready) {      ....      driver.get('about:blank').catch().quit().nodeify(alldone);      sessionisready = false;    } else {      pendingcancellations++;      process.nexttick(alldone);    }  });};when i run karma with existing virtual tunnel and setted startconnect: false - all work excellentbut when i run with creating virtual tunel (default) tunnel not closingand event driver.get('about:blank').catch().quit().nodeify(alldone);do not fired// karma.conf.jsvar customlaunchers = {    'sl_chrome': {      base: 'saucelabs'.      browsername: 'chrome'    }  };.....saucelabs: {      testname: 'karma and sauce labs demo'    }.    customlaunchers: customlaunchers.    browsers: object.keys(customlaunchers).    browsernoactivitytimeout: 60000.    capturetimeout: 120000.    singlerun: true.", "add a watch grunt task to use karma's autowatch", "> would it be worth splitting the session export/import functions to a separate module so we can test it properly?which ones? the stubs in `index.js`?  i'd kinda gone with keeping them as simple as possible to avoid having to test them. `exportroomkeys` and `importroomkeys` are tested in the js-sdk; `megolmexportencryption` is well-tested here (and can only be tested in-browser thanks to different crypto apis in node. so we can make good use of the karma infrastructure.)", 'a couple of tweaks to the karma config. * allow the imgs to be served from the karma server to avoid 404s* use the source-map-loader for js', 'the build failed because the travis have config issue`error [launcher]: cannot start chrome` then karma exits with 1', 'chore: add karma-junit-reporter to profile performance', 'chore(travis): use karma-coveralls for coverage reports. closes #171', "i'm not using ngscenario in the context of an angular app. we are using karma and the karma-ng-scenario plugin for testing generic websites. it seems like a great alternative to selenium. and we have no issues besides this one.", 'can you give a running example of this not working?  it may be the configuration of the application or karma?', "unfortunately i don't think the above change fixes this issue.  i'm seeing the entire serialized object included in the request. rather than simply an empty string.embarrassingly enough i'm not really currently set up to run karma tests normally. but as a quick test that i demonstrated the following test failing in our local build (thanks for the collaboration jeffbcross!):``` javascriptit('should not include a request body when calling $delete'. function() {  mockbackend.expect('delete'. '/fooresource'. null).respond({});  var resource = $resource('/fooresource');  var resource = new resource({ foo: 'bar' });  resource.$delete();  mockbackend.flush();});```"]