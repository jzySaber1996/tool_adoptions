["jacksongl my concern is that updating it would make it incompatible with those other implementations. if they don't support other hashing standards then we're breaking compatibility with those servers.that said. we should add optional support for another hashing algorithm asap. at some point in the future we can consider a breaking change that would modify the default algorithm.", "it's not the last argument that's elided. the standard canvas api lets you skip the fourth argument. defaulting it to zero. that doesn't seem to work in this implementation.", "keeping generated files out of repository. added ignore. the new standard will be to keep generated files out of the repository. so i'm excluding the generated go files and adding some ignores.", "focusing inputs / input refs. the standard way of focusing inputs doesn't work with rebass inputs. typically you pass a ref function. like `ref={(e) => e.focus()}` but the ref gets a null value on rebass not the input element.two possible solutions:- make the ref on an input component receive the input element. which might not be right since ref is supposed to be whatever the rendered element is. would be non-standard if it didn't include the label and container as well.- add a `focused` attribute to the input component that can be used to control if the element is focused or notlmk what you think", "related to #68 - afaik the only good solution is to change form elements into class components or wait for react to support a solution for functional components. lmk if i'm missing something obvious though.", 'document request timeout suggested defaults; take request timeout from connection string. hi - i\'m using a standard "connection string" method and it\'s taken me a literal age to dig through the code to find that you can a) pass config variables by simply adding them to the connection string and b) that **requesttimeout** needs to be specified as **request timeout=60000;**can i suggest that the connection readme is updated to explain thismany thanks.paul', 'levino i think webpack is not a standard that every package provider should look at. they just need to follow the npm standards. the standard is that the file can be a js or a json. and any module loader that loads packages should honour both.', 'all tests passing after i laid down one more commit to appease the `standard` gods.  should i merge as is or do you want me to rebase it first?', 'yozaz . thank you very much for your quick reply.i will contact undertone to see why they suggested using a 0x0 slot. there might be some confusion with their implementation since i think this is the first test of their bidder adapter. it could also be that the key value targeting is incorrect. thanks. i have a lot of things to check for debugging this problem.', 'matthewlane do we need a standard key for media type now?', "right. standard output doesn't do it. writing would be different but not an issue in ngl - sry and thx!", "should we have a github pr check for standard linting?also. we're using semistandard (standard + semicolons). not sure if there's any interest in changing it.", "somehow i missed this issue. emailjs are client libs as in they don't provide email mta or other server functionality. they do however connect to your server of choice. feel free to use them in your setting :)", 'do we have a standard way of introducing deprecation warnings into logs so end-users are nudged in the right direction?', 'allow specifying strictssl in the npm config file. the standard way of specifying whether you want strict-ssl or notis to add an entry into your npm config file for strict-ssl. usethat entry (which is passed to the install.js as an environmentvariable) to set the option for strictssl in electron-download.', 'will be released with the next electron release', 'fix linting issues. remove max-len around urls for vjsstandard update', "right now. we don't throw away any buffered content when you move to fullscreen. with our standard buffering settings. that means it can take up to 30 seconds for the player to adapt to the new dimensions.", '> springmeyer curious. does json.parse(feature.tojson()) emit valid geojson?feature.tojson() will return geojson that - to mapnik\'s best ability - represents the original geometry passed in. if the original geometry was "valid" then the output should be "valid". if the original geometry was invalid - say self intersecting rings which are not valid by ogc standards - then mapnik will return self intersecting rings because it does no sanitation.', "zkat i don't see how your proposal would help with the type of use cases most people need this feature for. how would anything be accomplished with a single shell command? something like `npm activate && standard` wouldn't work and is no improvement over the `npm-exec` ideas anyway.", 'from a "newbie" perspective...i\'m not a new developer. just new to nodejs.i have 4 projects i\'m building on my dev server to help me learn nodejs.prior to starting these projects. i had preinstalled (via npm -g) all the module dependancies (because it just makes sense to me to centralize and standardize all my generic dependancies like express. jade bower...). these are not products that will be changed by me - ever - only updated from time to time).each project has only between 5 and 10 files and represent less than 1 mb per project. but because i need the node_modules in the project folders (even symlinks duplicate a lot). the projects each have their own sub-folder structure of node_modules.this makes the total number of files for all 4 projects to be 4.316 files and about 400mb.i think it\'s an issue when a few little projects take up hundreds of times more disk space than the actual project files - just to duplicate the same files over and over.', "amilajack thanks for your reply! well. it was basically that i had to remove all these type annotations. if you have to do this. cherry-picking the boilerplate is a bit more work than just copy-pasting the code. not a big deal. but i guess there's not that many flow users out there. i myself prefer to stick to stuff that's standardized and am quite reluctant with picking up frameworks that may vanish or become unmaintained quickly. so. for me es6 is the way to go. even if i clearly see the benefits of strong typing.regarding the complex examples: that would be awesome. and i already saw that you're planning to provide a redux sample. awesome! this whole ipc stuff makes things quite complicated.", 'there is another issue with the current hook names. say you have an npm script called `commit`. then if you define a husky hook "precommit" and run `npm run commit` npm will also automatically execute `precommit` just because of the way npm-scripts work. is it possible to workaround this situation without renaming the `commit` script?', 'wizardzloy there is no way to workaround it right now', "oh `progress` is a dependency of `cucumber`. it wasn't written by me. it for one of the official reporter types. used by reporter `progress-bar`.however. you gave me a good idea. something i should have thought of before: i run protractor tests via gradle. which is notorious of its special way of handling standard i/o channels. so i will run some tests to confirm that is indeed just a problem of that.", 'hi tuananhtd . `dom-bindings` examples are not currently working since we are not done yet with setting up `pdf-kit` to work on a node standard environment. jbovenschen do you know if there is any progress on this? this is starting to cause lots of trouble.', 'could we change the scripts in package.json to look like``` json  "scripts":{    "test": "standard && grunt test".    "start": "grunt"  }.```(package.json can get the binary globals from the local node_modules so you don\'t need to hard code them)then remove start.js?']