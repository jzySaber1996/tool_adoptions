["should we expose the ability to deregister a component/tech?. ## proposalwe have a method to deregister a `plugin` called `deregisterplugin`. is there any reason not to have something similar for `component`'s and `tech`'s. i think that these methods would be:* `component.deregistercomponent`* `tech.deregistertech`### pro's* some unit tests will be easier* more standard api* there doesn't seem to be any good reason that `component`'s/`tech`'s should not be deregistered### con's * more code to support* may not be used by anyone outside of the video.js organization", "nope. it'll just override what's currently registered.", "in `tech`'s case it will also re-add that same component to `defaulttechorder_` twice. not sure if that will cause issues or not. seems like a major edge case bug.", "the example it tests does follow accessibility guidelines - it's just that automatic testing can't distinguish when one thing is turned off by javascript. and another thing is turned on. so it thinks the two elements overlay each other. that's why it's flagged as a warning. not an error - it's recommending that this issue is checked manually. there isn't a standard way to flag to the checker that this is okay. and shouldn't cause a warning. so the easiest thing is to turn off that warning. alternatively we could turn off all warnings. and just look for errors. but this gives better coverage than that approach.", "i had this same problem. changing the broadcast address did not work. the solution: remove my 'sonos bridge' from the sonos system. and either: connect ethernet directly to a speaker. or use standard wifi setup with the sonos. i went with the latter as sonos themselves have now deprecated the bridge device. the bridge must be blocking/dropping the broadcasts from getting onto the sonos-net where the speakers are (?). i didn't check this with wireshark though. so i might be wrong.", "arceglos isn't `process.node_env === 'production'` the de facto standard way to go?", "polapi prebid.js consentmanagement module does not generate consent strings. neither implements any vendor-specific allowences. it's a proxy. which looks for standard *__cmp()* function. gets encoded data. and passes it over for adapters.what i see as a possibility for prebid.js is instead of querying *__cmp()* function. it can accept config value (let's say. `pbjs.setconfig(consentstring:'xxxxx'`) and carry it through.", 'mag guidelines. this adds the mag guidelines to bbc-a11y. maps the existing tests onto them. adds new tests where there are gaps. and generally opens the code up for multiple standards mapped to a single set of tests.at this stage. most of the guidelines are implemented as manual tests. but they can be replaced with automated tests.', "feature request: `postshrinkwrap` lifecycle event. i'd find it very useful to have a `postshrinkwrap` lifecycle event that would be run _after_ `npm shrinkwrap`. specified in either the `scripts` section of `package.json` or in `node_modules/.hooks`.(while i don't need it. i suppose a `preshrinkwrap` event would make sense. too.)while i realize i might be (ab)using the `shrinkwrap` functionality in a somewhat non-standard way. i want to do a bit of normalization on the `npm-shrinkwrap.json` file--in my case. just normalizing the `resolved` url. while i can do this as a `pre-commit` hook in `git`. it'd be nice to do that immediately after the `npm-shrinkwrap.json` file is written.", 'i should mention that i tried using the `node_modules/.hooks/postinstall` lifecycle event. but that script is run _after_ the installation but before `npm-shrinkwrap.json` is updated.i suppose i could use `settimeout` there. but that seems a bit of an unstable hack.', 'i see the issue. so the "semistandard" prepublish fails because it can\'t find "htmlelement" a webcomponent feature.  how can i get it to ignore that check?  i tried environment targeting to browser but no fix.  this is getting sort of ridiculous just adding a few examples...', 'tc558 can we provide any additional assistance?', "tc558 i'm going to close this since there is no response.", 'onfilter returning error details rather than global "disallowed info_hash". since filter function has become async and receives a callback. perhaps it\'ll be good to have functionality for standard callback(err. res) form which allows for errors to be passed through. for customised error reasons.it\'ll be more usable than just having "disallowed info_hash" for every reason for failure.', '> for ghooks compatibility. actually i didn\'t see the benefit of supporting `ghooks` fields in `husky`sorry if it wasn\'t clear. but my main concerns were actually easing the upgrade path and not clobbering scripts. that could also be achieved by simply changing `pkg.config.ghooks` to `pkg.husky` and respecting the current ghooks format (could be automated. but trivial if manual).> i would feel it kind of intrusive for a package to do thatagreed.> that said. to make it easier for users. existing `ghooks` scripts in `.git/hooks` are automatically migrated.nice touch.> to be honest. i don\'t always have the time to reply to all...hope you\'re able to prioritize the migration over feature development assuming that\'s where most users could use you at present.> if `ghooks` suits you better. that\'s cooli\'d rather be using the more feature-rich and well-supported product. personally. and that\'s why i tried `husky` but as mentioned above i don\'t feel right updating the `scripts` object. updating the scripts object would result in stuff like this:```json"scripts": {  "pre-push": "npm run lint".  "lint": "standard"}```which seems to have a design smell which could lead to:- potential build breakage while taking a _major_ (reasonable. but perhaps not expected).- individuals spending time trying to figure out the origin of the magic hook scripts.- possible removal by individuals not understanding why those scripts are there.perhaps a `husky:pre-push` script. etc.. would mitigate the concerns above. if not creating a `pkg.husky`. but only time will tell i suppose.---at any rate. best of luck with the upgrade. looking forward to learning from husky over time.', 'husky runs ghooks twice. **package.json** ``` "scripts": {    "precommit": "npm test".    "commit": "git-cz".    "test": "grunt coffeelint"  }.```i run `npm run commit`. in this scenario. pre-commit happens before executing `git-cz` and again after while `git-cz` is making actual commit.also this works well for standard git commit commands', 'hi sibiraj-s.try to rename `commit` to `cz`. it happens because when you run `commit`. `npm` automatically runs `pre*` and `post*` scripts.', 'typicode i renamed it. then it when i got the error. everything works fine. i posted the issue to let know of this condition. is there thing that could be done on these scenarios', 'if the behaviour is fine. issue can be closed.', 'tinkerpop3-779: rfc for coalesce retain path. i tried to make some progress on this.  first. i added unit test to reproduce the bug.i then changed the child traversals from local to global. based on the fact that branchstep shows its branch traversals as global.  i\'m not entirely sure what this does. and it had no effect on the test.next. i tried to reimplement coalescestep using computerawarestep (instead of flatmapstep).  this seems necessary. since the child traversals can do whatever they want.  my test now passes in "standard" mode. but fails in "computer" mode.in "computer" mode. i\'m not sure how to implement the sequential "first successful child" logic.  what\'s in there now is "follow all paths" logic.  if it appears that i am on the right track. i can work more on this.', 'the problem with olap (global children) is that you can\'t do stuff like (as you say) "first successful child" as everything is executing in parallel and you don\'t know for which input what child output you are referring too. i suspect you could get fancy with path analysis. but then bulking goes away.we really need to make it so that global and local children behave "the same" as there are other steps that currently can\'t work in olap (e.g. `intersect()`. etc.).', 'i was also noticing that when i used the built-on riot emojii. i only get 8 emojii showing up. is this standard?', "yes. if one has date time setting preferences. one can of course offer dozens of ways to format them (see xkcd picture). if one has not. the best way to go is iso standard.also. do **not** expect that language and datetime format preference is coupled.if someone wants english. that doesn't necessarily mean he wants mm/dd/yyyy or so.", 'i would support the idea of implementing international standards (iso) in order to avoid using a system based on preference of a limited number of people.when translation comes. then maybe different format of date could be proposed.so the proposed :  `myip  2017-02-01 00:10:34`seems the more suitable to fit with the diversity of culture. language and practices of matrix users.', 'rageshake: abide by go standards. - host under `/api`', "it's only obvious if you are quite familiar with the standard library and its layout. so beginners could get quite befuddled as to the exact meaning. furthermore. it is not very google-friendly.  sometimes the changelog contains some of the most accessible documentation for some features. and a quick google is a good way to find it.  if the full module name isn't there. it could be missed.", 'fixed with 2d5710df58390f29ba6fe0c99e4259984d439577', 'in the setoid view of the world. which is the view taken by most of the standard library here. reflexivity only makes sense with respect to the equivalence relation of the underlying setoid. the induced equivalence relation of a preorder is in general coarser. and the preorder that has the induced equivalence relation as its setoid equivalence relation is an order (your `inducedposet`).in many cases (but not in all!) we will indeed start from preorders that use propositional equality as the equivalence underlying reflexivity - i tend to prefer to make that explicit. but notational support for that may still come in useful.  > the `inducedequivalence` does not care about the equivalence relationthat is okay. but `invispreorder` does care  - it re-uses it.> which is minimal of what is actually needed... in cases where what you have is a `reflexive` proof instead of the more general```    -- reflexivity is expressed in terms of an underlying equality:    reflexive : _[?]_ = _~_```using your `inducedstructures` with actual `preorder`s would require adaptation.as a matter of attitude. i recommend considering the setoids based on propositional equality to be the special case. and design for the general case.', "while enforcing es6 module paradigm over commonjs module might be a good goal to strive for in the long run. forcing users to add babel to their tool chain just to resolve es6<->commonjs differences is not practical.  ---es6 and commonjs module semantics are totally different. - in es6. you export names. it just so happen one of the names is `default`. it is perfectly valid to do `import {default as module} from 'module';` - in commonjs. you export one and only one javascript object. it can be anything. the mapping the two different semantic system is entirely non-standardized and determine by the transcompiler. so saying whether one syntax is correct or incorrect in that context is fairly arbitrary.", 'jprogrammer yes. please try again!  waiting on the edge of my chair to be able to use connect decorators in react.']