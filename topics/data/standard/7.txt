["unfortunately not. it's es6 from the start. :*)i can make a compatible one very easily or we have to wait for next year. your call...", "personally. i'm ok with waiting. in the meantime though. is it possible to add tests. particularly for the cache directory migration behavior?", "great idea. i discovered my implementation only to be working partially! now it's all good. added a test. :bulb:", '+1 for this. ready to merge. providing `--no-color` is implemented?', 'ok. it looks like it is now failing on the official node.js document generator api that is part of the offline document api. otherwise it seems to be working as intended. i could go through those files. and change them all to standard if needed. and it should remove any of the ci errors.actually. going to check out this eexists issue first.', "ok. i see now. it is catching the fs.stat error which isn't an actual error. let me quiet that down. and see if it will ignore the standard on the official after that. fix coming up.", 'kevinokerlund. the problem with this plugin is that it modifies the behavior of es modules in a non standard way.also. because webpack ends up consuming commonjs modules. it cannot perform tree-shaking optimizations anymore (even though tree-shaking is only partially working so far)..', "using host names as well as ipv4 addresses. right now tchannel accepts only ipv4 addresses to create socket. tchannel uses standard node 'net' module which accepts host names and ipv4 addresses. i believe we should allow users use any format which they want.", "i'm happy to change the wording. but there are many other instances of 'standard' in the code. so i would argue this makes the language _less_ consistent without a lot more replacement. do you think there any cases where the word 'standard' is correct. or can we replace all cases?", 'hi josh.i think we need to change all occurrences of "standard" for "guideline". once the new team site goes live (soon!) then the html v2 standards will be going away and becoming a guide.long term we\'ll have "guides and guidelines" where the guides are all platform specific guides to how to confirm to the guidelines. hope that helps.jamie + lion', "agree that referring to the guidelines as standards needs to be changed. i'm always wary of sweeping find-all-and-replace. however. as they sometimes pick up uses of a word that are correct and should not be changed.", 'move minimum text size under content resizing for now(and update manual testing questions - e)', 'review docs', "fantastic work josh! it's really taking shape well. last few points to wrap up and this should be good to merge. make the repo public again. and get the pre-release created.", 'discuss npm install behaviour: do not install locally if available globally. i would like to discuss here this feature.if approved. i could try to implement it. it does not look so complex.if i do `npm install` and a package. for instance _standard_. is in my devdependencies. but it is available globally. it would be nice if npm skips the local installation (which takes time) since the _standard_ package is already available globally.this could be governed by a flag. something like `npm install --skip-packages-available-globally` which is too verbose by now. just to have an idea.', "for the case of libraries -- node does not have a global search path. for the case of a command line tool like this. there may be a use case. but it seems too narrow to really save any time on the larger scale. since even some of those prefer to be installed locally per project.the use-case is even narrower when you take into account semver compatibility -- you might end up with a subset of subset of projects that are actually able to use this. and the optimization from having npm3's flattening already does a ton to easy this (along with our local caching).all-in-all. i can see the intent of this feature and really appreciate it. but it's very likely not something that would make it into the cli as far as my understanding of it goes. thanks for taking the time to write up the feature. as that is already appreciated <3", "offer a standard scripting interface for package / lifecycle scripts. this has been discussed in many places. but i'm not sure that it's been filed as a feature request now: the current cross-platform behavior requires people writing package scripts to use a very tightly-constrained subset of shell scripting syntax so that both windows and unix users can use the same scripts. this basically would involve choosing a simple subset of shell command syntax and then wrapping that around something like `shelljs`. thealphanerd had some thoughts as well.see also #1543 (add a `npm exec`). which is closely related.", "igorminar set angular as peer dependency of your polyfill. and let the user explicitly depend on both angular and the polyfill and require both and somehow pass at runtime the polyfill to angular.it's the standard peerdependency feature (at least now in npm3): the user is in control.", '(instead of command being `shjs`. maybe `shell` is fine.)', "app icon in development vs production. hi!i just build an app using this boilerplate and i added a custom icon in main.dev.js where is makes a new broswerwindow. but whenever i build it it says application icon not found uses standard electron icon. am i missing a place?`  mainwindow = new browserwindow({    show: false.    width: 1170.    height: 728.    icon: __dirname + '/icon.png'.    autohidemenubar: true  });`", 'hi.i integrate react-intl in my app ! maybe i can help !', 'i think pr must be closed :) just realized that `scope feature` is usable only for pre-commit case and can be implemented much more simpler way:```    // package.json    ...    "precommit": "npm run -s is_changed && lint-staged || true".    "is_changed": "[ $((git diff head --name-only; git ls-files -o --exclude-standard --modified) | grep \'^src\' | wc -l) -ne 0 ]".    ...```', "check for updates feature for electron app. would be nice if the app automatically checked for updates and had the standard menu item option for checking for updates so users don't have to follow the project on github or twitter to know when new releases are available.", 'i thought it diddbkr ?', "triaged as a: - bug (because it's a bug if as suspected this is an established feature that's not working) - p2 (because not picking up changes is something we should definitely fix soon if it's really happening) - major (because the whole 'feature' of detecting updates is broken. even if the desktop riot is still quite usable despite the failure)from the conversation above it _sounds_ like maybe everything's fine. but waiting on dbkr to verify that this is a feature that should exist before then spending any time checking if there's been a regression.", 'how necessary will this be once rte is standard?', "wasn't there something about not using the `fromnat` class in the standard library? i can't find any existing instances of `fromnat` anywhere in the current standard library. so while adding one is tempting. i think it might not be taken well?", 'gallais so. including something like the following. with the appropriate imports?```agdalevelnat : number levellevelnat .number.constraint _ = [?]levelnat .number.fromnat    n = # n```andreasabel i vaguely remember you being opposed to using `agda.builtin.fromnat` in the standard library. could you let me know if and if so why this is the case?', 'you can import the "instance" and then assign it to a proper instance yourself. i.e.```agdaimport level.literalsinstance levelnat = level.literals.levelnat```as far as i know. this is the recommended practice. if you search the standard library. then you will not find a single instance declaration anywhere.', '> you can import the "instance" and then assign it to a proper instance yourself>....> as far as i know. this is the recommended practice. if you search the standard library. then you will not find a single instance declaration anywhere.this is indeed the current policy (see #33).  it might well be a throwback to the when the instance feature wasn\'t well developed. however i\'ve encouraged it on the grounds that the standard library tries to keep proofs as explicit as possible. the overhead of `instance levelnat = level.literals.levelnat` probably isn\'t that great. and at least warns the reader that there is some instance magic about to happen...', "after merging. i've renamed `levelnat` to `levelN` as i've just remembered we don't tend to use `nat` much in the standard library.", "in my mind `coinduction` corresponded to `codata.thunk`. but it's true that there is also thedefinition of `rec` in there. not sure if it's worth having tbh: it's not standard to encode datatypesas a coinductive definition by enabling `--guardedness-preserving-type-constructors`.and there does not seem to be any results available. just the raw definition.", 'accessiblewebuk sorry - missed it. so that sounds like something we could consider recommending? 19px bold or 24px standard at minimum', "josephdenne are there any particular engines you'd like us to start with?what i've done so far is fully decouple dust from the core and turn it into its own module interface. similar to what jimlambie has been doing for api data stores. this interface consists of a set of standardised lifecycle functions that core will expect engines to implement (and will validate against).we can start taking this interface and building support for the various engines we want to ship with. but it also allows the community to build their own interfaces to add support for additional engines. this would happen in the same way they can currently install custom dust helpers and filters. which effectively needs you could use virtually any templating engine with web without having to touch the core.any thoughts appreciated!", '_flux-standard-action/index.d.ts_to author (tkqubo). could you review this pr?:+1: or :-1:?checklist- [ ] pass the travis ci test?', "seansfkelley i've been spending the past few days trying to tackle this issue. but i'm running into a couple of major roadblocks (correct me if i'm wrong on something):from what i've gathered. `connect` doesn't really function as a true class decorator (by typescript's standards) and isn't usable in its current form. the wrapped result of the connect call doesn't actually extend the targeted class. it uses its own type definition. typescript views decorated classes under the assumption that the resulting class will pass a `typeof` check on the target. this just simply isn't true with what react-redux is doing.the connect class returned is an entirely new class that wraps the targeted class. with its own unique set of props. this is the main block here is because the props that the connect class says are allowed are different than those that the class it's wrapping are. this is what causes the `types of property 'props' are incompatible.` message when using it as a decorator. typescript can't verify that the connect class is indeed a `typeof` the wrapped class because this offending property.to work around this. we can make the type declarations for props less strict. i am currently aware of two. the first is to say``` typescriptinterface stateprops {  mystate: mystate}interface dispatchprops { ... }interface ownprops { ... }connect<stateprops. dispatchprops. ownprops>(.... ...)export class mycomponent extends component<any. componentstate> { ... }```saying that any props are assignable on the component. this has the disadvantage that ts can't vaildate anything pertaining to props. the other (and i think better) way is to make every property in `stateprops` and `dispatchprops` optional:``` typescriptinterface stateprops {  mystate?: mystate}interface dispatchprops { ... }interface ownprops { ... }connect<stateprops. dispatchprops. ownprops>(.... ...)export class mycomponent extends component<ownprops & stateprops & dispatchprops. componentstate> { ... }```this way everything checks out. but ts can still complain if props in `ownprops` are omitted in jsx.", "thanks for pointing me to those. glad i'm not going crazy. is there any point in messing with this further until we have mapped types then?", 'in agreement. the "extend" method is also a public method (private in the typescript definition).', "yuit as the config documentation say about this method:if no directory is given. reads the standard config directory and parses node_config. so the configdir param is optional. and if there is no param take the 'rootpath/config' path by default.", 'core-js: split into standard and non-standard definitions. - [x] i want to talk about `core-js/core-js.d.ts`.  - the authors of that type definition are rbucktoni use the "shim only" part of core-js. unfortunately some non-standard part of the the full definitions conflict with some other definitions i have. and in general i\'d prefer only to have definitions for the parts i use.wouldn\'t it make sense to split the definitions into standard and non-standard. so that one can chose what he wants without getting conflicts (e.g. es5 target with default core-js => both standard and non-standard definitions. es5 with shim-only => only standard definitions. es6 with core-js => only non-standard definitions as ts will already include the compiler-provided es6 definitions).', "i haven't figured out a good way to handle these differences. the problem obviously comes down to the fact that isomorphic-fetch is really two different fetches. with different implementations and standards compliance.there are at least two ways to build a typings file for this situation. one option is to go with the common subset approach. which would remove all expected fetch typing information that was not in node-fetch. this would present problems for people who want to make full use of fetch in the browser. of course. a second option is to include everything in the browser-based fetch and rely on the developer to know what environment they're running in. and to know what is and isn't supported in node-fetch. this can lead to build or runtime errors. the second approach is what the current typings use. as you've pointed out. if it were possible to split out the browser-fetch superset. modulo the common subset. i think that would be very useful. i'm not sure how best to do that in a way that supports common environments and tools. if you have some ideas. i'd be interested in hearing them. thanks."]