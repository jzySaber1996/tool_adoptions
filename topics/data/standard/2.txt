['hi yugangw-msft. are you able to confirm whether the response body returned by the webapp api conforms to the standard clouderror?for example. i see that the c# implementation has details as a list of clouderror objects. where as in the response details has a list of key value pairs. only one of which is an "errorentity".', "justingreenberg jxnblk as per justingreenberg 's solution above. why can't the prop name be ref rather than baseref or am i missing something?also when can we expect a fix for this? are there concerns?", "i don't think it's wise for this library to implement some solution for `ref`s outside of react.  the 2 solutions i see are making form elements class components (as originally suggested) or add a higher-order component that wraps the stateless component in a class component.", 'phated the proposed solution above just provides a hook for `ref` on the base component... > the 2 solutions i see are making form elements class components (as originally suggested) or add a higher-order component that wraps the stateless component in a class component.can you provide some code or a demo? since all rebass components are wrapped in stateless function component (base hoc). afaik there is no other way to implement this functionality', "theseyi renaming ref to `baseref` prevents namespace conflicts and keeps the ref provider explicitly outside react's component api", "justingreenberg shouldn't it be that case that if the proposed solution is just a 'hook for `ref`' (which i'm interpreting as a proxy). then it should be the same name and just fall through to the react component?", "gucong3000 postcss-cli does support custom syntaxes via the `--syntax` option. however. since your syntax uses the non-standard `result.content`. postcss-cli can't work with that.we can't be special-casing everything. if postcss-html was a postcss-sponsered project. i'd consider it; but for now. not interested.", "theghostbel i don't understand as they bridge native events to observables.  the fromevent is obviously more complex as it has to account for non-standard events such as ie 6-8. as well as node.js.", "haha. yeah :) i think we'll get further if we favor some convention over configuration. at least at first. so. i'd say we include the router by default and standardize on webpack for building. same for testing. just pick one library. and leave other modules and packages up to the developer.", "scss file separation . would it be possible in the noty.scss file to either remove the themes imports or move the standard noty css to it's on scss file. this way we could compile the noty.css without the need to take in all the themes. we could choose which ones we want or use our own custom ones.", "madjam002 the solution i've settled on for that issue is that rather than using an npmignore. is to have a script for prepublishing (another reason prepublish is potentially not the best solution here) that gets everything ready. generated/transpiled etc. then tarballs just the files i want included. no npmignore to cause the issue. that way. but you still get to filter what's included in the standard install.", "madjam002 thanks for clarification. let's stay in touch.maxkorp i'm trying to grasp your reservation toward this approach.afaik when installing from local dir. first **all** the dependecies are installed (including dev dependencies) and then `prepublish` script is executed. so whatever you do to your code. you could put it in `prepublish` script and it will have the dependencies ready.maybe your prepublish logic requires external tools that are not available via npm? then you can just ask your team or contributors to install required software prior to installing your package via git. please consider that installing stuff from git repos is not meant to be standard distribution method. it is only meant to be used in development or staging environments. in production you will still probably use npmjs.org or private npm repository with everything prepared.btw nodegit looks really cool. i was looking for something like that.", 'cross-compiling idiom. i maintain an npm package with some platform-specific code. users have requested support for cross-compiling for other platforms.is there an agreed-upon idiom for expressing "install these npm packages to be run on target architecture x"? i saw some vague references on the internet to npm_config_arch and npm_config_platform. but nothing in the official npm docs.to be clear. i\'m not asking for npm to implement anything. i\'m asking if there\'s a standard that package maintainers can implement. obviously. every package could implement support for their own environment variable my_package_target_arch but this would become unwieldy for end-users of lots of packages.thanks!', "i think passing options as an object would be better than extra arguments for the reasons you state. and it's a pretty standard way of doing this.", "ya i think this'll become a breaking change but a good idea. > le sep 14. 2015 a 22:55. eric brelsford notificationsgithub.com a ecrit :> > i think passing options as an object would be better than extra arguments for the reasons you state. and it's a pretty standard way of doing this.> > --> reply to this email directly or view it on github.", "our company publishes web mapping services of taiwan only rather than a global scale.if there's no standard for cases like this. we would have different origins using services from different sources.", 'well. that only works if you control the html you\'re reading which in my case isn\'t true. i suspect zombie should follow the "be strict with what you do. be lenient with what you require" approach to standards.', "hey. thanks for opening this pr. i think this is a great suggestion. and linked data is super important!i'm hesitant to put any specific standards into dat. because then we'd have to support all of them. if people wanted to use `id` as the key they could do `--key=id`. is there a reason why the `-k id` interface isn't serving well? too much? often forgotten?at one point. we were thinking about putting a `dat add` function that would be a little more 'magic' to walk one through a data import. here. we could imagine a series of prompts -- one of them could try to auto-detect the unique key and ask you which column based upon that. i can imagine these kinds of higher-level features going into that.", 'ensure standard ligatures are enabled', 'lgtm. the semistandard bits are only spaces issue.', "matthewdaggitt. i just realized that the new `pointwise` datatype from data.vec.relation.pointwise.inductive does not typecheck when the `--without-k` option is enabled. while the old `pointwise'` from relation.binary.vec.pointwise did. some universe levels seem to have been dropped. is there any reason for that?i don't know if there's any policy w.r.t. the use of axiom k. but i think it might be good to have as little of the standard library rely on it as possible. wdyt?btw. the reason i checked with `--without-k` in the first place is that. as you point out. `pointwise` is now heterogeneous in the length of vectors. i'm a bit worried that that might also require k. but it's just a gut feeling. maybe jespercockx can tell us more.", "> some universe levels seem to have been dropped. is there any reason for that?which ones? could you point them out? if i have dropped universe levels. it's definitely an accident! i've spent quite a while adding them into various places in the library.> i don't know if there's any policy w.r.t. the use of axiom k. but i think it might be good to have as little of the standard library rely on it as possible. wdyt?there's definitely not an existing policy. if i were to come up with one on the fly i guess it is to minimise the use of it. except where it significantly impacts user experience. the question is whether the average user of `vec.pointwise` is more likely to be concerned with the usage of axiom k or is more likely to want proofs where the size of vectors are propositionally but not definitionally equal. i personally think the latter case will be more common (albeit on absolutely zero evidence). i'd welcome other opinions though and am definitely open to changing my mind. gallais thoughts?", 'added new `respects` types and tidied up `relation.binary.nonstricttostrict`. this adds explicit types to the two components of `_respects2_` in `relation.binary.core`. the left and right components are often useful on their own. and decomposing the product can be annoying.also standardised the names in `relation.binary.nonstricttostrict` and added some extra properties to the module.', 'added note on using semistandard.', "ah funny - really didn't see that at all.", 'thomasdarimont but this your note is more easy to see than this simple phrase"make sure the jshint and semistandard are happy and that all tests pass"', 'thanks for the contrib', "for you - would it not make sense to plugin qs?i suppose it's a bit more difficult in a non cjs/webpack/browserify environment.the idea here was to keep internal qs as simple as possible. is there even a standard way of parsing arrays?", 'yeah the more i dig the bigger the mess i see... is an empty array just not there. `foo[]=`. or `foo=` ? or maybe just `foo[]`? sigh... lack of standards here hurts.', '> sorry that i keep "rejecting" your pr proposalsnp. and honestly this was a question and i convinced myself against it. query string parsing is totally not standardized. so a simple parser in < 20 lines with the option of providing your own is the best way. which is what cherrytree does now.> just being careful with how the project evolvesthat\'s the right default reaction. any addition is ever ongoing maintenance. or a breaking change that requires upfront notice and user pain. i\'ve rejected more prs to `mocha-phantomjs` than i\'ve accepted in the last year or so :/', "move contribution guidelines. <!--- provide a summary of your changes in the title above -->## what problem does the pull request solve?this pr moves the contributing.md file out of the `.github/` folder. links to it from the readme and also updates the contibution guidelines to include more detail on standardjs.## screenshots (if appropriate):## what type of change is it?<!--- what types of changes does your code introduce? put an `x` in all the boxes that apply: -->- [ ] bug fix (non-breaking change which fixes an issue)- [x] new feature (non-breaking change which adds functionality)- [ ] breaking change (fix or feature that would cause existing functionality to change)## put an `x` in all the boxes that apply<!--- if you're unsure about any of these. don't hesitate to ask. we're here to help! -->- [x] my change requires a change to the documentation.- [x] i have updated the documentation accordingly.- [x] i have read the **contributing** document.", 'updating example to use standard promise syntax. examples were using deprecated .success and .error rather .then', 'i think this is not really much of a bc. it is really just providing a better error message for an invalid input.regarding the fact that it does not throw on false: this is standard practice for filters. since often they receive `null` or `undefined` initially while waiting for watch values to kick in.']